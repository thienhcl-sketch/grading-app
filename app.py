"""
EduScan Bootstrapper & Full App Generator

This is a safe Python bootstrapper that generates a runnable EduScan MVP project on disk.

How to use:
1. Save and run this script in an empty directory: `python create_eduscan.py`.
2. A folder `eduscan-mvp/` will be created with source, UI, backend, sample data and helper scripts.
3. Follow printed instructions to install dependencies and run the app locally or produce a Windows .exe.

Why this exists:
Previously the canvas contained large markdown inside a `code/python` block which caused SyntaxError when executed.
This script writes proper files to disk so Python never tries to execute markdown text.

This generator also creates two useful helper scripts:
- `start_app.bat` (Windows) to start backend + Streamlit UI together
- `build_exe.bat` (Windows) to create a single-file .exe using PyInstaller

It includes a minimal, working Streamlit UI and a small FastAPI backend stub so the whole system can be tested end-to-end.
"""

from pathlib import Path
import json

ROOT = Path('eduscan-mvp')
ROOT.mkdir(exist_ok=True)


def write_file(rel_path: str, content: str) -> None:
    p = ROOT / rel_path
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(content, encoding='utf-8')
    print(f'Wrote: {p}')

# README
README = '''# EduScan - MVP (Generated)

This project is an MVP for automatic grading of multiple-choice answer sheets.

Folders and files were generated by a bootstrapper script. See instructions below to run locally.

---

Quick start (local):

1. Create a virtual environment (recommended):

   python -m venv venv
   # Windows: venv\Scripts\activate
   # macOS/Linux: source venv/bin/activate

2. Install dependencies:

   pip install -r requirements.txt

3. Start backend (in one terminal):

   uvicorn app.backend:app --reload --port 8000

4. Start Streamlit UI (in another terminal):

   streamlit run ui/streamlit_app.py

5. Open http://localhost:8501 in your browser.

---

Packaging to Windows .exe (optional):

1. Install PyInstaller: `pip install pyinstaller`
2. Run the supplied script `build_exe.bat` (Windows) which calls pyinstaller.

Notes:
- The pipeline is template-based (simple pixel thresholding). For robust production use, apply ML models (YOLO/EasyOCR) and more image augmentation/data.
- The generated app writes to a local SQLite database (`eduscan.db`).
'''
write_file('README.md', README)

# requirements
REQS = '''fastapi
uvicorn[standard]
python-multipart
pillow
opencv-python
numpy
pandas
openpyxl
sqlmodel
streamlit
requests
pytest
pyinstaller
'''
write_file('requirements.txt', REQS)

# sample answer key
AK = {
  "1": "A",
  "2": "B",
  "3": "C",
  "4": "D",
  "5": "A",
  "6": "C",
  "7": "B",
  "8": "D",
  "9": "A",
  "10": "B"
}
write_file('sample_data/answer_key.json', json.dumps(AK, indent=2))

# backend (FastAPI) - lightweight stub
BACKEND = r'''from fastapi import FastAPI, UploadFile, File
from fastapi.responses import JSONResponse
from app.pipeline import process_image
from app.db import init_db, save_submission, get_test_results
import uuid, shutil, os

app = FastAPI()

UPLOAD_DIR = 'uploads'
os.makedirs(UPLOAD_DIR, exist_ok=True)

@app.on_event('startup')
def on_startup():
    init_db()

@app.post('/upload-image')
async def upload_image(file: UploadFile = File(...), test_id: str = 'default'):
    file_id = str(uuid.uuid4())
    path = os.path.join(UPLOAD_DIR, f'{file_id}_{file.filename}')
    with open(path, 'wb') as f:
        shutil.copyfileobj(file.file, f)

    results = process_image(path)
    for r in results:
        save_submission(test_id=test_id, stt=r.get('stt','0'), answers=r.get('answers',{}), score=r.get('score',0), confidence=r.get('confidence',0.0), image_path=path)

    return JSONResponse({'status': 'ok', 'processed': len(results), 'results': results})

@app.get('/results/{test_id}')
def results(test_id: str):
    rows = get_test_results(test_id)
    # safe sort by integer stt
    def stt_key(r):
        try:
            return int(r.get('student_stt', '0'))
        except Exception:
            return 0
    return sorted(rows, key=stt_key)
'''
write_file('app/backend.py', BACKEND)

# pipeline - simple template-based pipeline (robust guards)
PIPELINE = r'''import cv2
import numpy as np
import json
from typing import List, Dict

TEMPLATE = {
    'stt_region': (0.05, 0.02, 0.2, 0.08),
    'questions': []
}

# simple demo template generator
def build_demo_template(n_q=10):
    qs = []
    start_x = 0.1
    start_y = 0.2
    box_w = 0.06
    box_h = 0.05
    gap_x = 0.07
    for i in range(n_q):
        x_base = start_x + i*gap_x
        opts = []
        for j in range(4):
            opts.append((x_base, start_y + j*(box_h+0.01), box_w, box_h))
        qs.append(opts)
    TEMPLATE['questions'] = qs

build_demo_template(10)

# Safe crop by relative box
def crop_rel(img, rel_box):
    if img is None:
        raise ValueError('img is None')
    h, w = img.shape[:2]
    x = int(rel_box[0]*w)
    y = int(rel_box[1]*h)
    bw = int(rel_box[2]*w)
    bh = int(rel_box[3]*h)
    x = max(0, min(x, w-1))
    y = max(0, min(y, h-1))
    bw = max(1, min(bw, w - x))
    bh = max(1, min(bh, h - y))
    return img[y:y+bh, x:x+bw]

# detect filled bubble by fraction of dark pixels
def detect_bubble_selected(bubble_crop) -> float:
    if bubble_crop is None or getattr(bubble_crop, 'size', 0) == 0:
        return 0.0
    gray = cv2.cvtColor(bubble_crop, cv2.COLOR_BGR2GRAY)
    try:
        _, th = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    except Exception:
        _, th = cv2.threshold(gray, 128, 255, cv2.THRESH_BINARY_INV)
    kernel = np.ones((3,3), np.uint8)
    th = cv2.morphologyEx(th, cv2.MORPH_OPEN, kernel)
    frac = (th>0).sum() / (th.size)
    return float(frac)

# read STT region using simple tesseract-like fallback (no external OCR required here)
def read_stt(img) -> str:
    crop = crop_rel(img, TEMPLATE['stt_region'])
    gray = cv2.cvtColor(crop, cv2.COLOR_BGR2GRAY)
    try:
        gray = cv2.equalizeHist(gray)
    except Exception:
        pass
    # no OCR engine in this minimal demo; return '0' to indicate unknown
    return '0'

# process single sheet
def process_single_sheet(img) -> Dict:
    stt = read_stt(img)
    answers = {}
    confidences = []
    for qi, opts in enumerate(TEMPLATE['questions'], start=1):
        scores = []
        for opt_box in opts:
            crop = crop_rel(img, opt_box)
            frac = detect_bubble_selected(crop)
            scores.append(frac)
        if not scores:
            choice = 'N'
            conf_val = 0.0
        else:
            choice_idx = int(np.argmax(scores))
            choice_map = ['A','B','C','D']
            choice = choice_map[choice_idx] if choice_idx < len(choice_map) else 'N'
            conf_val = float(max(scores))
        answers[str(qi)] = choice
        confidences.append(conf_val)

    try:
        with open('sample_data/answer_key.json','r') as f:
            answer_key = json.load(f)
    except Exception:
        answer_key = {}
    correct = 0
    for k,v in answers.items():
        if k in answer_key and answer_key[k].upper() == v:
            correct += 1
    score = correct
    conf = float(np.mean(confidences)) if confidences else 1.0
    return {'stt': stt, 'answers': answers, 'score': score, 'confidence': conf}

# for single-sheet input
def split_pages(img) -> List[np.ndarray]:
    return [img]

# main entry
def process_image(path: str) -> List[Dict]:
    img = cv2.imread(path)
    if img is None:
        return []
    pages = split_pages(img)
    results = []
    for p in pages:
        r = process_single_sheet(p)
        results.append(r)
    return results
'''
write_file('app/pipeline.py', PIPELINE)

# database (SQLite via SQLModel)
DB = r'''from sqlmodel import SQLModel, Field, create_engine, Session, select
from typing import Optional
import json

DATABASE_URL = 'sqlite:///eduscan.db'
engine = create_engine(DATABASE_URL, echo=False)

class Submission(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    test_id: str
    student_stt: str
    answers_json: str
    score: int
    confidence: float
    image_path: str


def init_db():
    SQLModel.metadata.create_all(engine)


def save_submission(test_id, stt, answers, score, confidence, image_path):
    s = Submission(test_id=test_id, student_stt=str(stt), answers_json=json.dumps(answers), score=int(score), confidence=float(confidence), image_path=image_path)
    with Session(engine) as session:
        session.add(s)
        session.commit()
        session.refresh(s)
    return s.id


def get_test_results(test_id):
    with Session(engine) as session:
        q = session.exec(select(Submission).where(Submission.test_id == test_id)).all()
        rows = []
        for r in q:
            rows.append({'id': r.id, 'student_stt': r.student_stt, 'answers': json.loads(r.answers_json), 'score': r.score, 'confidence': r.confidence, 'image_path': r.image_path})
        return rows
'''
write_file('app/db.py', DB)

# utils
UTILS = r'''import pandas as pd
from app.db import get_test_results


def export_results_to_excel(test_id, out_path='results.xlsx'):
    rows = get_test_results(test_id)
    if not rows:
        return None
    for r in rows:
        r['answers_str'] = ','.join([f"{k}:{v}" for k,v in r['answers'].items()])
    df = pd.DataFrame([{'STT': r['student_stt'], 'Score': r['score'], 'Confidence': r['confidence'], 'Answers': r['answers_str'], 'Image': r['image_path']} for r in rows])
    try:
        df_sorted = df.sort_values(by=['STT'], key=lambda col: col.astype(int))
    except Exception:
        df_sorted = df
    df_sorted.to_excel(out_path, index=False)
    return out_path
'''
write_file('app/utils.py', UTILS)

# Streamlit UI (simple)
UI = r'''import streamlit as st
import requests
from PIL import Image
import io
from app.utils import export_results_to_excel

API_URL = st.secrets.get('api_url','http://localhost:8000')

st.set_page_config(page_title='EduScan MVP', layout='wide')
st.title('EduScan - Teacher UI (MVP)')

st.sidebar.header('Controls')
test_id = st.sidebar.text_input('Test ID', 'default')
uploaded = st.sidebar.file_uploader('Upload scanned image (jpg/png)', type=['jpg','jpeg','png'])

if uploaded is not None:
    bytes_data = uploaded.getvalue()
    files = {'file': (uploaded.name, bytes_data, uploaded.type)}
    with st.spinner('Uploading to backend and processing...'):
        try:
            r = requests.post(f'{API_URL}/upload-image', files=files, params={'test_id': test_id})
            data = r.json()
            st.success(f"Processed: {data.get('processed', 0)} submission(s)")
            st.json(data)
        except Exception as e:
            st.error(f'Error calling backend: {e}')

if st.button('View results'):
    try:
        r = requests.get(f'{API_URL}/results/{test_id}')
        if r.status_code == 200:
            data = r.json()
            st.write(f'Results for {test_id} (sorted by STT)')
            st.table(data)
            out = export_results_to_excel(test_id, out_path=f'results_{test_id}.xlsx')
            if out:
                st.markdown(f'[Download Excel]({out})')
        else:
            st.error('No data')
    except Exception as e:
        st.error(f'Error fetching results: {e}')
'''
write_file('ui/streamlit_app.py', UI)

# start_app.bat (Windows) helper to launch both backend and UI
START_BAT = r'''@echo off
REM Start backend
start "EduScan Backend" cmd /k "cd "%~dp0" & uvicorn app.backend:app --reload --port 8000"
REM Start Streamlit UI
start "EduScan UI" cmd /k "cd "%~dp0" & streamlit run ui/streamlit_app.py"
'''
write_file('start_app.bat', START_BAT)

# build_exe.bat (Windows) helper to create a single EXE for UI only
BUILD_BAT = r'''@echo off
REM Build a single-file executable for the UI using PyInstaller
REM Ensure you run this from the project folder and have activated your venv
pyinstaller --noconfirm --onefile --add-data "app;app" --add-data "ui;ui" ui/streamlit_app.py

echo Build finished. See dist/streamlit_app.exe
'''
write_file('build_exe.bat', BUILD_BAT)

# docker-compose.yml
DOCKER = '''version: '3.8'
services:
  api:
    build: .
    ports:
      - '8000:8000'
    volumes:
      - .:/app
'''
write_file('docker-compose.yml', DOCKER)

# Dockerfile
DOCKERFILE = '''FROM python:3.10-slim
WORKDIR /app
COPY . /app
RUN pip install --upgrade pip && pip install -r requirements.txt
CMD ["uvicorn","app.backend:app","--host","0.0.0.0","--port","8000"]
'''
write_file('Dockerfile', DOCKERFILE)

# Basic tests
TESTS = r'''import re
from pathlib import Path

def test_readme_exists():
    p = Path('eduscan-mvp/README.md')
    assert p.exists()

def test_readme_no_box_chars():
    p = Path('eduscan-mvp/README.md')
    text = p.read_text(encoding='utf-8')
    box_chars = re.compile(r'[─-╿]')
    assert not box_chars.search(text)

def test_requirements():
    p = Path('eduscan-mvp/requirements.txt')
    assert p.exists()
    assert 'fastapi' in p.read_text()
'''
write_file('tests/test_basic.py', TESTS)

print('
Project generation complete: eduscan-mvp/'))
print('To run:')
print('  cd eduscan-mvp')
print('  python -m venv venv')
print('  # activate venv then: pip install -r requirements.txt')
print('  uvicorn app.backend:app --reload --port 8000')
print('  streamlit run ui/streamlit_app.py')

print('
You can also run start_app.bat (Windows) to start backend + UI.'))

if __name__ == '__main__':
    print('Generator finished.')
